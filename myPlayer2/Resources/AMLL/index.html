<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMLL Lyrics</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }
        #player {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .amll-lyric-player {
            font-family: var(--amll-lp-main-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-main-font-weight, 600);
        }
        .amll-lyric-player.dom,
        .amll-lyric-player.dom-slim {
            line-height: 1.44em;
        }
        ._lyricLine_m23bz_6,
        ._lyricLine_1jop6_6 {
            overflow: visible;
        }
        ._lyricMainLine_m23bz_99,
        ._lyricMainLine_1jop6_80 {
            font-family: var(--amll-lp-main-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-main-font-weight, 600);
            line-height: 1.42em;
            padding-bottom: 1.05em;
        }
        ._lyricSubLine_m23bz_145,
        ._lyricSubLine_1jop6_90 {
            font-family: var(--amll-lp-translation-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-translation-font-weight, 400);
            font-size: var(--amll-lp-translation-font-size, 0.75em);
            line-height: 1.42em;
        }

        /* Background (small) lyric lines:
           hidden by default, fade in only when active, fade out after active ends. */
        .amll-lyric-player [class*="_lyricBgLine_"] {
            opacity: 0 !important;
            padding-top: 0.2em !important;
            padding-bottom: 0.2em !important;
            scale: 1 !important;
            transition: opacity .32s ease !important;
        }
        .amll-lyric-player [class*="_lyricBgLine_"][class*="_active_"] {
            opacity: 0.4 !important;
            scale: 1 !important;
        }

        /* Animate text inside bg-line so we don't override AMLL line positioning transform. */
        .amll-lyric-player [class*="_lyricBgLine_"] > * {
            transform: translateY(10px);
            transition: transform .42s ease, opacity .32s ease;
        }
        .amll-lyric-player [class*="_lyricBgLine_"][class*="_active_"] > * {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="player"></div>

    <!-- Load Bridge first so logs & AMLL namespace are available -->
    <script src="bridge.js"></script>

    <script type="module">
        import { LyricPlayer, parseTTML } from "./amll-core.js";

        console.log("[LyricsRenderer] Module script loaded");

        // Initialize Player
        const playerContainer = document.getElementById('player');
        const lyricPlayer = new LyricPlayer();
        playerContainer.appendChild(lyricPlayer.getElement());
        
        // Initial config defaults
        lyricPlayer.setEnableSpring(true);
        lyricPlayer.setEnableBlur(true);
        lyricPlayer.setWordFadeWidth(0.7);
        // Align active line toward top (instead of center)
        lyricPlayer.setAlignAnchor("top");
        lyricPlayer.setAlignPosition(0.2);
        
        // Helper to map TTML lines to AMLL LyricLine format
        const mapTTMLLyric = (line) => ({
            ...line,
            words: line.words.map((word) => ({ obscene: false, romanWord: "", ...word })),
            romanLyric: "",
        });

        let lastSeekAt = 0;
        let lastSeekSeconds = null;
        const emitSeek = (line) => {
            if (!line) return;
            const start = typeof line.startTime === "number" ? line.startTime : undefined;
            if (start === undefined || Number.isNaN(start)) return;

            const currentMs = typeof lyricPlayer.getCurrentTime === "function"
                ? lyricPlayer.getCurrentTime()
                : 0;
            const looksLikeMs = start > 1000 || (currentMs > 0 && Math.abs(start - currentMs) < 5000);
            const seconds = looksLikeMs ? start / 1000 : start;

            const now = performance.now();
            if (lastSeekSeconds !== null && Math.abs(seconds - lastSeekSeconds) < 0.01 && now - lastSeekAt < 250) {
                return;
            }
            lastSeekAt = now;
            lastSeekSeconds = seconds;

            if (window.AMLL && typeof window.AMLL._onUserSeek === "function") {
                window.AMLL._onUserSeek(seconds);
            } else if (window.webkit?.messageHandlers?.onUserSeek) {
                window.webkit.messageHandlers.onUserSeek.postMessage({ seconds });
            }
        };

        const resolveLineFromTarget = (target) => {
            let node = target;
            const root = lyricPlayer.getElement();
            while (node && node !== root) {
                const lineObj = lyricPlayer.lyricLineElementMap?.get?.(node);
                if (lineObj?.getLine) return lineObj.getLine();
                node = node.parentElement;
            }
            return null;
        };

        // Seek on line click (notify native)
        lyricPlayer.addEventListener("line-click", (e) => {
            emitSeek(e?.line);
        });

        // Fallback: resolve clicked line from DOM target (some WebKit builds drop line-click)
        lyricPlayer.getElement().addEventListener("click", (e) => {
            const line = resolveLineFromTarget(e.target);
            emitSeek(line);
        });

        const parseTTMLTimeToMs = (value) => {
            if (typeof value !== "string" || value.length === 0) return null;
            if (value.endsWith("ms")) {
                const n = Number.parseFloat(value.slice(0, -2));
                return Number.isFinite(n) ? Math.round(n) : null;
            }
            if (value.endsWith("s")) {
                const n = Number.parseFloat(value.slice(0, -1));
                return Number.isFinite(n) ? Math.round(n * 1000) : null;
            }
            const parts = value.split(":");
            if (parts.length === 2 || parts.length === 3) {
                const nums = parts.map((part) => Number.parseFloat(part));
                if (nums.some((n) => !Number.isFinite(n))) return null;
                if (parts.length === 2) {
                    return Math.round((nums[0] * 60 + nums[1]) * 1000);
                }
                return Math.round((nums[0] * 3600 + nums[1] * 60 + nums[2]) * 1000);
            }
            const raw = Number.parseFloat(value);
            return Number.isFinite(raw) ? Math.round(raw * 1000) : null;
        };

        const collectXBgFromTTML = (ttml) => {
            if (typeof ttml !== "string" || ttml.trim().length === 0) return [];
            const xml = new DOMParser().parseFromString(ttml, "application/xml");
            if (xml.querySelector("parsererror")) {
                return [];
            }

            const nodes = Array.from(xml.getElementsByTagName("*")).filter((el) => {
                if (el.localName !== "span") return false;
                const role =
                    el.getAttribute("ttm:role")
                    || el.getAttributeNS("http://www.w3.org/ns/ttml#metadata", "role")
                    || el.getAttribute("role");
                return role === "x-bg";
            });

            return nodes.map((node) => {
                const words = Array.from(node.children)
                    .filter((child) => child.localName === "span")
                    .map((child) => ({
                        startTime: parseTTMLTimeToMs(child.getAttribute("begin")),
                        endTime: parseTTMLTimeToMs(child.getAttribute("end")),
                        text: (child.textContent || "").trim(),
                    }));
                return {
                    startTime: parseTTMLTimeToMs(node.getAttribute("begin")),
                    endTime: parseTTMLTimeToMs(node.getAttribute("end")),
                    words,
                };
            });
        };

        const assertXBgTiming = (ttml, parsedLines) => {
            const source = collectXBgFromTTML(ttml);
            if (source.length === 0) return;

            const parsed = (Array.isArray(parsedLines) ? parsedLines : [])
                .filter((line) => line?.isBG)
                .map((line) => ({
                    startTime: Number.isFinite(line.startTime) ? line.startTime : null,
                    endTime: Number.isFinite(line.endTime) ? line.endTime : null,
                    words: Array.isArray(line.words)
                        ? line.words.map((word) => ({
                            startTime: Number.isFinite(word.startTime) ? word.startTime : null,
                            endTime: Number.isFinite(word.endTime) ? word.endTime : null,
                            text: (word.word || "").trim(),
                        }))
                        : [],
                }));

            console.log(
                `[LyricsRenderer][x-bg][assert] source=${source.length}, parsed=${parsed.length}`
            );
            if (source.length !== parsed.length) {
                console.error("[LyricsRenderer][x-bg][assert] line count mismatch");
            }

            const n = Math.min(source.length, parsed.length);
            for (let i = 0; i < n; i++) {
                const src = source[i];
                const expected = {
                    startTime: Number.isFinite(src.startTime) ? Math.max(0, src.startTime + timeOffsetMs) : null,
                    endTime: Number.isFinite(src.endTime) ? Math.max(0, src.endTime + timeOffsetMs) : null,
                    words: src.words.map((word) => ({
                        startTime: Number.isFinite(word.startTime)
                            ? Math.max(0, word.startTime + timeOffsetMs)
                            : null,
                        endTime: Number.isFinite(word.endTime)
                            ? Math.max(0, word.endTime + timeOffsetMs)
                            : null,
                        text: word.text,
                    })),
                };
                const got = parsed[i];
                const startOk = expected.startTime === got.startTime;
                const endOk = expected.endTime === got.endTime;
                const wordCountOk = expected.words.length === got.words.length;
                const firstWordStartOk =
                    expected.words.length === 0
                    || got.words.length === 0
                    || expected.words[0].startTime === got.words[0].startTime;
                const lastWordEndOk =
                    expected.words.length === 0
                    || got.words.length === 0
                    || expected.words[expected.words.length - 1].endTime === got.words[got.words.length - 1].endTime;
                const ok = startOk && endOk && wordCountOk && firstWordStartOk && lastWordEndOk;

                if (ok) {
                    console.log(
                        `[LyricsRenderer][x-bg][assert] #${i} PASS start=${got.startTime} end=${got.endTime} words=${got.words.length}`
                    );
                } else {
                    console.error(
                        `[LyricsRenderer][x-bg][assert] #${i} FAIL expected=${JSON.stringify(expected)} parsed=${JSON.stringify(got)}`
                    );
                }
            }
        };

        const captureTimingSnapshot = (lines) => {
            if (!Array.isArray(lines)) return [];
            return lines.map((line) => ({
                startTime: Number.isFinite(line?.startTime) ? line.startTime : null,
                endTime: Number.isFinite(line?.endTime) ? line.endTime : null,
                words: Array.isArray(line?.words)
                    ? line.words.map((word) => ({
                        startTime: Number.isFinite(word?.startTime) ? word.startTime : null,
                        endTime: Number.isFinite(word?.endTime) ? word.endTime : null,
                    }))
                    : [],
            }));
        };

        const applyTimingSnapshot = (lines, snapshot) => {
            if (!Array.isArray(lines) || !Array.isArray(snapshot) || lines.length !== snapshot.length) {
                return false;
            }
            lines.forEach((line, idx) => {
                const snap = snapshot[idx];
                if (!line || !snap) return;
                if (Number.isFinite(snap.startTime)) line.startTime = snap.startTime;
                if (Number.isFinite(snap.endTime)) line.endTime = snap.endTime;
                if (!Array.isArray(line.words) || !Array.isArray(snap.words)) return;
                const wordCount = Math.min(line.words.length, snap.words.length);
                for (let wi = 0; wi < wordCount; wi++) {
                    const word = line.words[wi];
                    const wordSnap = snap.words[wi];
                    if (!word || !wordSnap) continue;
                    if (Number.isFinite(wordSnap.startTime)) word.startTime = wordSnap.startTime;
                    if (Number.isFinite(wordSnap.endTime)) word.endTime = wordSnap.endTime;
                }
            });
            return true;
        };

        const restoreTimingSnapshot = (snapshot) => {
            const didProcessed = applyTimingSnapshot(lyricPlayer.processedLines, snapshot);
            const didCurrent = applyTimingSnapshot(lyricPlayer.currentLyricLines, snapshot);
            const objectLines = Array.isArray(lyricPlayer.currentLyricLineObjects)
                ? lyricPlayer.currentLyricLineObjects
                    .map((obj) => obj?.getLine?.() ?? obj?.lyricLine)
                    .filter(Boolean)
                : [];
            const didObjects = applyTimingSnapshot(objectLines, snapshot);
            return didProcessed || didCurrent || didObjects;
        };

	        let lastKnownTimeMs = 0;
	        let bgActiveIndexes = new Set();
	        // Main-line indexes that were force-exited by the near-gap early-switch logic.
	        // Used to keep BG lines in sync (BG should hide when its paired main hides).
	        let forcedExitedMainLines = new Set();
        const getPairedMainLineIndex = (index) => {
            if (!Array.isArray(lyricPlayer.processedLines)) return -1;
            if (index > 0 && lyricPlayer.processedLines[index - 1] && !lyricPlayer.processedLines[index - 1].isBG) {
                return index - 1;
            }
            if (
                index + 1 < lyricPlayer.processedLines.length
                && lyricPlayer.processedLines[index + 1]
                && !lyricPlayer.processedLines[index + 1].isBG
            ) {
                return index + 1;
            }
            return -1;
        };
	        const isMainLineStillVisible = (index) => {
	            if (index < 0) return false;
	            if (forcedExitedMainLines.has(index)) return false;
	            if (lyricPlayer.hotLines?.has(index) || lyricPlayer.bufferedLines?.has(index)) {
	                return true;
	            }
	            const mainObj = lyricPlayer.currentLyricLineObjects?.[index];
	            return mainObj?.isEnabled === true;
	        };
        const enforceBGTimingWindows = (timeMs, force = false) => {
            if (!Array.isArray(lyricPlayer.currentLyricLineObjects)) {
                bgActiveIndexes = new Set();
                return false;
            }

            const lines = lyricPlayer.processedLines;
            const nextActive = new Set();
            let layoutChanged = false;
            const isPlaying = typeof lyricPlayer.getIsPlaying === "function"
                ? lyricPlayer.getIsPlaying()
                : true;

            // Only consider BG lines that are relevant right now:
            // - previously active BG lines
            // - BG lines already in hot/buffered sets
            // - BG lines paired with currently-hot main lines (core may have enabled them early)
            const candidateIndexes = new Set();
            const addIndex = (idx) => {
                if (!Number.isInteger(idx) || idx < 0) return;
                candidateIndexes.add(idx);
            };
            for (const idx of bgActiveIndexes) addIndex(idx);
            for (const idx of (lyricPlayer.hotLines ?? [])) {
                addIndex(idx);
                const maybeMain = lines?.[idx];
                if (maybeMain && !maybeMain.isBG) {
                    const bgIdx = findPairedBgIndex(idx);
                    if (bgIdx !== -1) addIndex(bgIdx);
                }
            }
            for (const idx of (lyricPlayer.bufferedLines ?? [])) addIndex(idx);

            for (const idx of candidateIndexes) {
                const lineObj = lyricPlayer.currentLyricLineObjects[idx];
                const line = lineObj?.getLine?.() ?? lineObj?.lyricLine;
                if (!line?.isBG) continue;

                const pairedMainIndex = getPairedMainLineIndex(idx);
                const mainStillVisible = isMainLineStillVisible(pairedMainIndex);
                const inOwnTimeWindow =
                    Number.isFinite(line.startTime)
                    && Number.isFinite(line.endTime)
                    && timeMs >= line.startTime
                    && timeMs < line.endTime;
                const started = Number.isFinite(line.startTime) && timeMs >= line.startTime;
                const mainForcedExit = forcedExitedMainLines.has(pairedMainIndex);
                const shouldBeActive = !mainForcedExit && (inOwnTimeWindow || (started && mainStillVisible));
                const wasActive = bgActiveIndexes.has(idx);
                const isEnabled = lineObj?.isEnabled === true;

                if (shouldBeActive) {
                    nextActive.add(idx);
                    if (!lyricPlayer.hotLines?.has(idx)) {
                        lyricPlayer.hotLines?.add(idx);
                        layoutChanged = true;
                    }
                    if (!lyricPlayer.bufferedLines?.has(idx)) {
                        lyricPlayer.bufferedLines?.add(idx);
                        layoutChanged = true;
                    }
                    if (!isEnabled && typeof lineObj?.enable === "function") {
                        lineObj.enable(timeMs, isPlaying);
                    }
                    if ((force || !wasActive) && typeof lineObj?.setMaskAnimationState === "function") {
                        lineObj.setMaskAnimationState(timeMs);
                    }
                } else {
                    if (lyricPlayer.hotLines?.has(idx)) {
                        lyricPlayer.hotLines.delete(idx);
                        layoutChanged = true;
                    }
                    if (lyricPlayer.bufferedLines?.has(idx)) {
                        lyricPlayer.bufferedLines.delete(idx);
                        layoutChanged = true;
                    }
                    // Core can enable BG lines early when a main line becomes hot. Always disable if it's enabled
                    // but not within its own timing window (prevents "plays twice" and early animation).
                    if ((wasActive || isEnabled) && typeof lineObj?.disable === "function") {
                        lineObj.disable();
                    }
                }
            }

            bgActiveIndexes = nextActive;
            return layoutChanged;
        };

	        // Ensure time is integer ms and keep x-bg activation tied to its own begin/end.
	        // Also implements "near-gap early switch": if next line starts very soon after current ends,
	        // switch layout focus to next line early (leadInMs), and let current line exit quickly.
	        const coreSetCurrentTime = lyricPlayer.setCurrentTime.bind(lyricPlayer);
	        const nearSwitchEndOverrides = new Map(); // mainIndex -> { originalEnd: number, restoreAt: number }
	        const nearSwitchFastExited = new Set(); // indexes (main and bg) we've already fast-disabled
	        const getOriginalMainEndTime = (index, line) => {
	            const info = nearSwitchEndOverrides.get(index);
	            if (info && Number.isFinite(info.originalEnd)) return info.originalEnd;
	            return Number.isFinite(line?.endTime) ? line.endTime : null;
	        };
	        const findNextMainIndex = (fromIndex) => {
	            if (!Array.isArray(lyricPlayer.processedLines)) return -1;
	            for (let i = fromIndex + 1; i < lyricPlayer.processedLines.length; i++) {
	                const line = lyricPlayer.processedLines[i];
	                if (line && !line.isBG) return i;
	            }
	            return -1;
	        };
	        const findPairedBgIndex = (mainIndex) => {
	            if (!Array.isArray(lyricPlayer.processedLines)) return -1;
	            const bgIndex = mainIndex + 1;
	            if (bgIndex >= 0 && bgIndex < lyricPlayer.processedLines.length && lyricPlayer.processedLines[bgIndex]?.isBG) {
	                return bgIndex;
	            }
	            return -1;
	        };
	        const restoreExpiredNearSwitchOverrides = (timeMs, forceClear = false) => {
	            if (forceClear) {
	                for (const [idx, info] of nearSwitchEndOverrides.entries()) {
	                    const line = lyricPlayer.processedLines?.[idx];
	                    if (line && Number.isFinite(info.originalEnd)) {
	                        line.endTime = info.originalEnd;
	                    }
	                }
	                nearSwitchEndOverrides.clear();
	                nearSwitchFastExited.clear();
	                forcedExitedMainLines = new Set();
	                return;
	            }
	            for (const [idx, info] of nearSwitchEndOverrides.entries()) {
	                if (!info || !Number.isFinite(info.restoreAt)) continue;
	                if (timeMs < info.restoreAt) continue;
	                const line = lyricPlayer.processedLines?.[idx];
	                if (line && Number.isFinite(info.originalEnd)) {
	                    line.endTime = info.originalEnd;
	                }
	                nearSwitchEndOverrides.delete(idx);
	            }
	        };
	        const fastDisableLineObject = (index) => {
	            const obj = lyricPlayer.currentLyricLineObjects?.[index];
	            if (!obj || typeof obj.disable !== "function") return;
	            try {
	                obj.disable();
	                // Speed up the reverse "float" so the line can exit quickly.
	                const words = obj.splittedWords;
	                if (!Array.isArray(words)) return;
	                for (const w of words) {
	                    const anims = w?.elementAnimations;
	                    if (!Array.isArray(anims)) continue;
	                    for (const anim of anims) {
	                        const id = anim?.id || "";
	                        if (!id) continue;
	                        if (id === "float-word" || id.includes("emphasize-word-float")) {
	                            anim.playbackRate = -6;
	                            anim.play();
	                        }
	                    }
	                }
	            } catch (e) {
	                // ignore
	            }
	        };
	        let nearSwitchGapMs = 70;
	        let lastNearSwitchMainIndex = -1;
	        const toMainIndex = (idx) => {
	            const lines = lyricPlayer.processedLines;
	            if (!Array.isArray(lines)) return -1;
	            if (!Number.isInteger(idx) || idx < 0 || idx >= lines.length) return -1;
	            const line = lines[idx];
	            if (line && !line.isBG) return idx;
	            return getPairedMainLineIndex(idx);
	        };
	        const pickCurrentMainIndex = () => {
	            const lines = lyricPlayer.processedLines;
	            if (!Array.isArray(lines) || lines.length === 0) return -1;
	
	            // Prefer the latest hot main line (handles overlaps).
	            let hotMain = -1;
	            for (const idx of (lyricPlayer.hotLines ?? [])) {
	                const line = lines[idx];
	                if (!line || line.isBG) continue;
	                if (idx > hotMain) hotMain = idx;
	            }
	            if (hotMain !== -1) {
	                lastNearSwitchMainIndex = hotMain;
	                return hotMain;
	            }
	
	            // Fall back to previous main index if still valid.
	            if (
	                Number.isInteger(lastNearSwitchMainIndex)
	                && lastNearSwitchMainIndex >= 0
	                && lastNearSwitchMainIndex < lines.length
	                && lines[lastNearSwitchMainIndex]
	                && !lines[lastNearSwitchMainIndex].isBG
	            ) {
	                return lastNearSwitchMainIndex;
	            }
	
	            // Last fall back: derive from scrollToIndex (may point to BG or main).
	            const guessed = toMainIndex(lyricPlayer.scrollToIndex);
	            if (guessed !== -1) {
	                lastNearSwitchMainIndex = guessed;
	                return guessed;
	            }
	            return -1;
	        };
	        const findNearSwitchCandidate = (timeMs) => {
	            const lines = lyricPlayer.processedLines;
	            if (!Array.isArray(lines) || lines.length === 0) return null;
	            if (!Number.isFinite(nearSwitchGapMs) || nearSwitchGapMs <= 0) return null;
	            if (!Number.isFinite(leadInMs) || leadInMs <= 0) return null;

	            const currentMain = pickCurrentMainIndex();
	            if (currentMain === -1) return null;
	            const nextMain = findNextMainIndex(currentMain);
	            if (nextMain === -1) return null;
	
	            const currentLine = lines[currentMain];
	            const nextLine = lines[nextMain];
	            const currentEnd = getOriginalMainEndTime(currentMain, currentLine);
	            const nextStart = nextLine?.startTime;
	            if (!Number.isFinite(currentEnd) || !Number.isFinite(nextStart)) return null;
	
	            const gap = nextStart - currentEnd;
	            if (!(gap >= 0 && gap < nearSwitchGapMs)) return null;
	
	            const currentStart = Number.isFinite(currentLine?.startTime) ? currentLine.startTime : currentEnd;
	            const switchAt = Math.max(currentStart, currentEnd - leadInMs);
	            // No need to run near-switch far ahead of its active window.
	            if (timeMs + 8 < switchAt) return null;
	            return {
	                currentIndex: currentMain,
	                nextIndex: nextMain,
	                currentEnd,
	                nextStart,
	                gap,
	                switchAt,
	            };
	        };
	        const ensureNearSwitchCutoff = (candidate, cutoffMs) => {
	            if (!candidate) return;
	            const idx = candidate.currentIndex;
	            const line = lyricPlayer.processedLines?.[idx];
	            if (!line || line.isBG) return;
	            const originalEnd = getOriginalMainEndTime(idx, line);
	            const lineStart = Number.isFinite(line.startTime) ? line.startTime : 0;
	            const targetEnd = Math.max(lineStart, Math.min(originalEnd ?? line.endTime, cutoffMs));
	            if (!Number.isFinite(targetEnd) || targetEnd <= 0) return;
	            if (!nearSwitchEndOverrides.has(idx)) {
	                nearSwitchEndOverrides.set(idx, { originalEnd: originalEnd ?? line.endTime, restoreAt: candidate.nextStart });
	            }
	            if (!Number.isFinite(line.endTime) || line.endTime > targetEnd) {
	                line.endTime = targetEnd;
	            }
	        };
	        const enforceNearSwitch = (timeMs, candidate) => {
	            if (!candidate) return false;
	            if (!(timeMs >= candidate.switchAt && timeMs < candidate.nextStart)) return false;
	            if (nearSwitchFastExited.has(candidate.currentIndex)) return false;
	
	            let layoutChanged = false;
	            const ensureBuffered = (idx) => {
	                if (idx === -1) return;
	                if (!lyricPlayer.bufferedLines?.has(idx)) {
	                    lyricPlayer.bufferedLines?.add(idx);
	                    layoutChanged = true;
	                }
	            };
	            const removeHotBuffered = (idx) => {
	                if (idx === -1) return;
	                if (lyricPlayer.hotLines?.has(idx)) {
	                    lyricPlayer.hotLines.delete(idx);
	                    layoutChanged = true;
	                }
	                if (lyricPlayer.bufferedLines?.has(idx)) {
	                    lyricPlayer.bufferedLines.delete(idx);
	                    layoutChanged = true;
	                }
	            };
	
	            const curBg = findPairedBgIndex(candidate.currentIndex);
	            const nextBg = findPairedBgIndex(candidate.nextIndex);

	            // One-shot switch: prevent core from re-activating current line in following ticks.
	            ensureNearSwitchCutoff(candidate, timeMs);
	            forcedExitedMainLines.add(candidate.currentIndex);
	            nearSwitchFastExited.add(candidate.currentIndex);
	            removeHotBuffered(candidate.currentIndex);
	            removeHotBuffered(curBg);

	            // Keep target line around so layout can settle on next line immediately.
	            ensureBuffered(candidate.nextIndex);
	            ensureBuffered(nextBg);
	
	            // Focus the layout on the next line.
	            if (lyricPlayer.scrollToIndex !== candidate.nextIndex) {
	                lyricPlayer.scrollToIndex = candidate.nextIndex;
	                layoutChanged = true;
	            }
	            lastNearSwitchMainIndex = candidate.nextIndex;
	
	            // Force-exit the current main line (and its BG) immediately.
	            fastDisableLineObject(candidate.currentIndex);
	            if (curBg !== -1) {
	                nearSwitchFastExited.add(curBg);
	                fastDisableLineObject(curBg);
	            }
	            return layoutChanged;
	        };
	        const originalSetCurrentTime = (ms, force = false) => {
	            const timeMs = Math.max(0, Math.floor(ms));
	            const prevTimeMs = lastKnownTimeMs;
	            const delta = Math.abs(timeMs - lastKnownTimeMs);
	            const timeWentBack = timeMs + 50 < prevTimeMs;
	            const isSeekLike = force || delta > 800 || timeWentBack;
	            let layoutDirty = false;
	            if (isSeekLike) {
	                lastNearSwitchMainIndex = -1;
	            }
	
	            lastKnownTimeMs = timeMs;
	
	            // Clear any temporary state on seeks / big jumps / backwards time.
	            restoreExpiredNearSwitchOverrides(timeMs, isSeekLike);
	
	            const candidate = findNearSwitchCandidate(timeMs);
	
	            coreSetCurrentTime(timeMs, isSeekLike);
	
	            // Apply near-gap early switch behavior (layout + fast exit).
	            if (enforceNearSwitch(timeMs, candidate)) layoutDirty = true;
	
	            // BG enforcement should run after near-switch so forcedExitedMainLines takes effect.
	            if (enforceBGTimingWindows(timeMs, isSeekLike || delta > 500)) layoutDirty = true;
	
	            if (layoutDirty && typeof lyricPlayer.calcLayout === "function") {
	                lyricPlayer.calcLayout();
	            }
	        };
	        lyricPlayer.setCurrentTime = originalSetCurrentTime;
	        let leadInMs = 300;
	        let timeOffsetMs = 0;
	        let lastTTML = "";
	        const applyTimeOffset = (line) => {
	            if (!line) return;
	            const offset = Number.isFinite(timeOffsetMs) ? timeOffsetMs : 0;
	            if (!offset) return;
            const adjust = (value) => Math.max(0, value + offset);

            if (Number.isFinite(line.startTime)) {
                line.startTime = adjust(line.startTime);
            }
            if (Number.isFinite(line.endTime)) {
                line.endTime = Math.max(
                    Number.isFinite(line.startTime) ? line.startTime : 0,
                    adjust(line.endTime)
                );
            }
            if (Array.isArray(line.words)) {
                line.words.forEach((word) => {
                    if (Number.isFinite(word.startTime)) {
                        word.startTime = adjust(word.startTime);
                    }
                    if (Number.isFinite(word.endTime)) {
                        word.endTime = Math.max(
                            Number.isFinite(word.startTime) ? word.startTime : 0,
                            adjust(word.endTime)
                        );
                    }
                });
            }
        };

        // Define the Renderer Implementation for Bridge
        window.LyricsRenderer = {
            setLyrics: (ttml) => {
                if (!ttml) {
                    lyricPlayer.setLyricLines([]);
                    bgActiveIndexes = new Set();
                    console.log("[LyricsRenderer] Cleared lyrics");
                    lastTTML = "";
                    return;
                }
                try {
	                    lastTTML = ttml;
	                    const result = parseTTML(ttml);
	                    const lines = result.lines.map(mapTTMLLyric);
	                    lines.forEach(applyTimeOffset);
		                    const timingSnapshot = captureTimingSnapshot(lines);
		                    // Preserve TTML intent (no mutation of duet/bg/ordering).
		                    lyricPlayer.setLyricLines(lines);
	                    const currentMs = Number.isFinite(lastKnownTimeMs)
	                        ? lastKnownTimeMs
	                        : (lyricPlayer.getCurrentTime ? lyricPlayer.getCurrentTime() : 0);
	                    // Undo core timing normalization so x-bg keeps original line/word timing.
	                    restoreTimingSnapshot(timingSnapshot);
	                    // Core may have already generated mask animations based on its normalized timing.
	                    // Rebuild masks for currently-built lines so per-word highlight uses restored TTML timing.
	                    if (Array.isArray(lyricPlayer.currentLyricLineObjects)) {
	                        for (const obj of lyricPlayer.currentLyricLineObjects) {
	                            if (obj?.built && typeof obj.updateMaskImageSync === "function") {
	                                obj.updateMaskImageSync();
	                            }
	                        }
	                    }
	                    assertXBgTiming(ttml, lines);
	                    // Re-align playback position after (re)loading lyrics.
	                    originalSetCurrentTime(currentMs, true);
	                    console.log("[LyricsRenderer] Loaded lines:", lines.length);
	                } catch (e) {
                    console.error("[LyricsRenderer] TTML Parse Error:", e);
                    // Optionally fallback to plain text parsing if you had that logic
                }
            },
            
            setCurrentTime: (seconds) => {
                const timeInMs = Math.max(0, Math.floor(seconds * 1000));
                // If AMLL hasn't finished its first layout yet, non-forced setCurrentTime is ignored.
                const needsForce = lyricPlayer.initialLayoutFinished === false;
                originalSetCurrentTime(timeInMs, needsForce);
            },
            
            setPlaying: (isPlaying) => {
                // lyricPlayer.setIsPlaying(isPlaying); // If supported by core
            },
            
            setConfig: (config) => {
                try {
                    // Apply config to lyricPlayer
                    if (config.fontSize) {
                         lyricPlayer.getElement().style.setProperty("--amll-lp-font-size", `${config.fontSize}px`);
                    }
                    if (config.fontWeight) {
                        lyricPlayer.getElement().style.setProperty("--amll-lp-main-font-weight", `${config.fontWeight}`);
                    }
                    if (config.translationFontWeight) {
                        lyricPlayer.getElement().style.setProperty(
                            "--amll-lp-translation-font-weight",
                            `${config.translationFontWeight}`
                        );
                    }
                    if (config.translationFontSize) {
                        lyricPlayer.getElement().style.setProperty(
                            "--amll-lp-translation-font-size",
                            `${config.translationFontSize}px`
                        );
                    }
                    if (config.fontFamilyMain) {
                        lyricPlayer.getElement().style.setProperty("--amll-lp-main-font-family", config.fontFamilyMain);
                    }
                    if (config.fontFamilyTranslation) {
                        lyricPlayer.getElement().style.setProperty(
                            "--amll-lp-translation-font-family",
                            config.fontFamilyTranslation
                        );
                    }
                    if (config.textColor) {
                        lyricPlayer.getElement().style.setProperty("--amll-lp-color", config.textColor);
                    }
                    if (config.shadowColor) {
                        lyricPlayer.getElement().style.textShadow = `0 1px 2px ${config.shadowColor}`;
                    }
	                    if (typeof config.leadInMs === "number" && !Number.isNaN(config.leadInMs)) {
	                        leadInMs = Math.max(0, Math.min(1200, config.leadInMs));
	                        // Lead-in affects near-gap early-switch behavior; clear any cached state.
	                        restoreExpiredNearSwitchOverrides(lastKnownTimeMs, true);
	                    }
	                    if (typeof config.nearSwitchGapMs === "number" && !Number.isNaN(config.nearSwitchGapMs)) {
	                        nearSwitchGapMs = Math.max(0, Math.min(300, config.nearSwitchGapMs));
	                        restoreExpiredNearSwitchOverrides(lastKnownTimeMs, true);
	                    }
	                    if (typeof config.timeOffsetMs === "number" && !Number.isNaN(config.timeOffsetMs)) {
	                        timeOffsetMs = Math.max(-15000, Math.min(15000, config.timeOffsetMs));
	                        if (lastTTML) {
	                            window.LyricsRenderer.setLyrics(lastTTML);
                        }
                    }
                    console.log("[LyricsRenderer] Config updated:", config);
                } catch (e) {
                    console.error("[LyricsRenderer] Config Error:", e);
                }
            }
        };

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const delta = time - lastTime;
            lastTime = time;
            lyricPlayer.update(delta);
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        // Notify bridge that renderer is ready (after LyricsRenderer defined)
        if (window.AMLL && typeof window.AMLL._onRendererReady === "function") {
            window.AMLL._onRendererReady();
        } else {
            console.warn("[LyricsRenderer] AMLL bridge not ready");
        }

    </script>
</body>
</html>
