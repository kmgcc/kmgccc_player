<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMLL Lyrics</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }
        #player {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .amll-lyric-player {
            font-family: var(--amll-lp-main-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-main-font-weight, 600);
        }
        .amll-lyric-player.dom,
        .amll-lyric-player.dom-slim {
            line-height: 1.44em;
        }
        ._lyricLine_m23bz_6,
        ._lyricLine_1jop6_6 {
            overflow: visible;
        }
        ._lyricMainLine_m23bz_99,
        ._lyricMainLine_1jop6_80 {
            font-family: var(--amll-lp-main-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-main-font-weight, 600);
            line-height: 1.42em;
            padding-bottom: 1.05em;
        }
        ._lyricSubLine_m23bz_145,
        ._lyricSubLine_1jop6_90 {
            font-family: var(--amll-lp-translation-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-translation-font-weight, 400);
            font-size: var(--amll-lp-translation-font-size, 0.75em);
            line-height: 1.42em;
        }

        /* Background (small) lyric lines:
           hidden by default, fade in only when active, fade out after active ends. */
        .amll-lyric-player [class*="_lyricBgLine_"] {
            opacity: 0 !important;
            padding-top: 0.2em !important;
            padding-bottom: 0.2em !important;
            scale: 1 !important;
            transition: opacity .32s ease !important;
        }
        .amll-lyric-player [class*="_lyricBgLine_"][class*="_active_"] {
            opacity: 0.4 !important;
            scale: 1 !important;
        }

        /* Animate text inside bg-line so we don't override AMLL line positioning transform. */
        .amll-lyric-player [class*="_lyricBgLine_"] > * {
            transform: translateY(10px);
            transition: transform .42s ease, opacity .32s ease;
        }
        .amll-lyric-player [class*="_lyricBgLine_"][class*="_active_"] > * {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="player"></div>

    <!-- Load Bridge first so logs & AMLL namespace are available -->
    <script src="bridge.js"></script>

    <script type="module">
        import { LyricPlayer, parseTTML } from "./amll-core.js";

        console.log("[LyricsRenderer] Module script loaded");

        // Initialize Player
        const playerContainer = document.getElementById('player');
        const lyricPlayer = new LyricPlayer();
        playerContainer.appendChild(lyricPlayer.getElement());
        
        // Initial config defaults
        lyricPlayer.setEnableSpring(true);
        lyricPlayer.setEnableBlur(true);
        lyricPlayer.setWordFadeWidth(0.7);
        let renderScale = 0.75;
        if (typeof lyricPlayer.setRenderScale === "function") {
            lyricPlayer.setRenderScale(renderScale);
        }
        // Remove core's default 30fps ticker cap if API is available.
        if (typeof lyricPlayer.setFPS === "function") {
            lyricPlayer.setFPS(0);
        }
        let externalTimeMs = 0;
        let externalTimeAnchorPerfMs = performance.now();
        let externalIsPlaying = true;
        // Align active line toward top (instead of center)
        lyricPlayer.setAlignAnchor("top");
        lyricPlayer.setAlignPosition(0.2);
        
        // Helper to map TTML lines to AMLL LyricLine format
        const mapTTMLLyric = (line) => ({
            ...line,
            words: line.words.map((word) => ({ obscene: false, romanWord: "", ...word })),
            romanLyric: "",
        });

        let lastSeekAt = 0;
        let lastSeekSeconds = null;
        const emitSeek = (line) => {
            if (!line) return;
            const start = typeof line.startTime === "number" ? line.startTime : undefined;
            if (start === undefined || Number.isNaN(start)) return;

            const currentMs = typeof lyricPlayer.getCurrentTime === "function"
                ? lyricPlayer.getCurrentTime()
                : 0;
            const looksLikeMs = start > 1000 || (currentMs > 0 && Math.abs(start - currentMs) < 5000);
            const seconds = looksLikeMs ? start / 1000 : start;

            const now = performance.now();
            if (lastSeekSeconds !== null && Math.abs(seconds - lastSeekSeconds) < 0.01 && now - lastSeekAt < 250) {
                return;
            }
            lastSeekAt = now;
            lastSeekSeconds = seconds;

            if (window.AMLL && typeof window.AMLL._onUserSeek === "function") {
                window.AMLL._onUserSeek(seconds);
            } else if (window.webkit?.messageHandlers?.onUserSeek) {
                window.webkit.messageHandlers.onUserSeek.postMessage({ seconds });
            }
        };

        const resolveLineFromTarget = (target) => {
            let node = target;
            const root = lyricPlayer.getElement();
            while (node && node !== root) {
                const lineObj = lyricPlayer.lyricLineElementMap?.get?.(node);
                if (lineObj?.getLine) return lineObj.getLine();
                node = node.parentElement;
            }
            return null;
        };

        // Seek on line click (notify native)
        lyricPlayer.addEventListener("line-click", (e) => {
            emitSeek(e?.line);
        });

        // Fallback: resolve clicked line from DOM target (some WebKit builds drop line-click)
        lyricPlayer.getElement().addEventListener("click", (e) => {
            const line = resolveLineFromTarget(e.target);
            emitSeek(line);
        });

        const parseTTMLTimeToMs = (value) => {
            if (typeof value !== "string" || value.length === 0) return null;
            if (value.endsWith("ms")) {
                const n = Number.parseFloat(value.slice(0, -2));
                return Number.isFinite(n) ? Math.round(n) : null;
            }
            if (value.endsWith("s")) {
                const n = Number.parseFloat(value.slice(0, -1));
                return Number.isFinite(n) ? Math.round(n * 1000) : null;
            }
            const parts = value.split(":");
            if (parts.length === 2 || parts.length === 3) {
                const nums = parts.map((part) => Number.parseFloat(part));
                if (nums.some((n) => !Number.isFinite(n))) return null;
                if (parts.length === 2) {
                    return Math.round((nums[0] * 60 + nums[1]) * 1000);
                }
                return Math.round((nums[0] * 3600 + nums[1] * 60 + nums[2]) * 1000);
            }
            const raw = Number.parseFloat(value);
            return Number.isFinite(raw) ? Math.round(raw * 1000) : null;
        };

        const collectXBgFromTTML = (ttml) => {
            if (typeof ttml !== "string" || ttml.trim().length === 0) return [];
            const xml = new DOMParser().parseFromString(ttml, "application/xml");
            if (xml.querySelector("parsererror")) {
                return [];
            }

            const nodes = Array.from(xml.getElementsByTagName("*")).filter((el) => {
                if (el.localName !== "span") return false;
                const role =
                    el.getAttribute("ttm:role")
                    || el.getAttributeNS("http://www.w3.org/ns/ttml#metadata", "role")
                    || el.getAttribute("role");
                return role === "x-bg";
            });

            return nodes.map((node) => {
                const words = Array.from(node.children)
                    .filter((child) => child.localName === "span")
                    .map((child) => ({
                        startTime: parseTTMLTimeToMs(child.getAttribute("begin")),
                        endTime: parseTTMLTimeToMs(child.getAttribute("end")),
                        text: (child.textContent || "").trim(),
                    }));
                return {
                    startTime: parseTTMLTimeToMs(node.getAttribute("begin")),
                    endTime: parseTTMLTimeToMs(node.getAttribute("end")),
                    words,
                };
            });
        };

        const assertXBgTiming = (ttml, parsedLines) => {
            const source = collectXBgFromTTML(ttml);
            if (source.length === 0) return;

            const parsed = (Array.isArray(parsedLines) ? parsedLines : [])
                .filter((line) => line?.isBG)
                .map((line) => ({
                    startTime: Number.isFinite(line.startTime) ? line.startTime : null,
                    endTime: Number.isFinite(line.endTime) ? line.endTime : null,
                    words: Array.isArray(line.words)
                        ? line.words.map((word) => ({
                            startTime: Number.isFinite(word.startTime) ? word.startTime : null,
                            endTime: Number.isFinite(word.endTime) ? word.endTime : null,
                            text: (word.word || "").trim(),
                        }))
                        : [],
                }));

            console.log(
                `[LyricsRenderer][x-bg][assert] source=${source.length}, parsed=${parsed.length}`
            );
            if (source.length !== parsed.length) {
                console.error("[LyricsRenderer][x-bg][assert] line count mismatch");
            }

            const n = Math.min(source.length, parsed.length);
            for (let i = 0; i < n; i++) {
                const src = source[i];
                const expected = {
                    startTime: Number.isFinite(src.startTime) ? Math.max(0, src.startTime + timeOffsetMs) : null,
                    endTime: Number.isFinite(src.endTime) ? Math.max(0, src.endTime + timeOffsetMs) : null,
                    words: src.words.map((word) => ({
                        startTime: Number.isFinite(word.startTime)
                            ? Math.max(0, word.startTime + timeOffsetMs)
                            : null,
                        endTime: Number.isFinite(word.endTime)
                            ? Math.max(0, word.endTime + timeOffsetMs)
                            : null,
                        text: word.text,
                    })),
                };
                const got = parsed[i];
                const startOk = expected.startTime === got.startTime;
                const endOk = expected.endTime === got.endTime;
                const wordCountOk = expected.words.length === got.words.length;
                const firstWordStartOk =
                    expected.words.length === 0
                    || got.words.length === 0
                    || expected.words[0].startTime === got.words[0].startTime;
                const lastWordEndOk =
                    expected.words.length === 0
                    || got.words.length === 0
                    || expected.words[expected.words.length - 1].endTime === got.words[got.words.length - 1].endTime;
                const ok = startOk && endOk && wordCountOk && firstWordStartOk && lastWordEndOk;

            }
        };

        const captureTimingSnapshot = (lines) => {
            if (!Array.isArray(lines)) return [];
            return lines.map((line) => ({
                startTime: Number.isFinite(line?.startTime) ? line.startTime : null,
                endTime: Number.isFinite(line?.endTime) ? line.endTime : null,
                words: Array.isArray(line?.words)
                    ? line.words.map((word) => ({
                        startTime: Number.isFinite(word?.startTime) ? word.startTime : null,
                        endTime: Number.isFinite(word?.endTime) ? word.endTime : null,
                    }))
                    : [],
            }));
        };

        const applyTimingSnapshot = (lines, snapshot) => {
            if (!Array.isArray(lines) || !Array.isArray(snapshot) || lines.length !== snapshot.length) {
                return false;
            }
            lines.forEach((line, idx) => {
                const snap = snapshot[idx];
                if (!line || !snap) return;
                if (Number.isFinite(snap.startTime)) line.startTime = snap.startTime;
                if (Number.isFinite(snap.endTime)) line.endTime = snap.endTime;
                if (!Array.isArray(line.words) || !Array.isArray(snap.words)) return;
                const wordCount = Math.min(line.words.length, snap.words.length);
                for (let wi = 0; wi < wordCount; wi++) {
                    const word = line.words[wi];
                    const wordSnap = snap.words[wi];
                    if (!word || !wordSnap) continue;
                    if (Number.isFinite(wordSnap.startTime)) word.startTime = wordSnap.startTime;
                    if (Number.isFinite(wordSnap.endTime)) word.endTime = wordSnap.endTime;
                }
            });
            return true;
        };

        const restoreTimingSnapshot = (snapshot) => {
            const didProcessed = applyTimingSnapshot(lyricPlayer.processedLines, snapshot);
            const didCurrent = applyTimingSnapshot(lyricPlayer.currentLyricLines, snapshot);
            const objectLines = Array.isArray(lyricPlayer.currentLyricLineObjects)
                ? lyricPlayer.currentLyricLineObjects
                    .map((obj) => obj?.getLine?.() ?? obj?.lyricLine)
                    .filter(Boolean)
                : [];
            const didObjects = applyTimingSnapshot(objectLines, snapshot);
            return didProcessed || didCurrent || didObjects;
        };

	        let lastKnownTimeMs = 0;
	        let bgActiveIndexes = new Set();
	        // Main-line indexes that were force-hidden by runtime logic.
	        // Kept for BG visibility sync.
	        let forcedExitedMainLines = new Set();
        const getPairedMainLineIndex = (index) => {
            if (!Array.isArray(lyricPlayer.processedLines)) return -1;
            if (index > 0 && lyricPlayer.processedLines[index - 1] && !lyricPlayer.processedLines[index - 1].isBG) {
                return index - 1;
            }
            if (
                index + 1 < lyricPlayer.processedLines.length
                && lyricPlayer.processedLines[index + 1]
                && !lyricPlayer.processedLines[index + 1].isBG
            ) {
                return index + 1;
            }
            return -1;
        };
	        const isMainLineStillVisible = (index) => {
	            if (index < 0) return false;
	            if (forcedExitedMainLines.has(index)) return false;
	            if (lyricPlayer.hotLines?.has(index) || lyricPlayer.bufferedLines?.has(index)) {
	                return true;
	            }
	            const mainObj = lyricPlayer.currentLyricLineObjects?.[index];
	            return mainObj?.isEnabled === true;
	        };
        const enforceBGTimingWindows = (timeMs, force = false) => {
            if (!Array.isArray(lyricPlayer.currentLyricLineObjects)) {
                bgActiveIndexes = new Set();
                return false;
            }

            const lines = lyricPlayer.processedLines;
            const nextActive = new Set();
            let layoutChanged = false;
            const isPlaying = typeof lyricPlayer.getIsPlaying === "function"
                ? lyricPlayer.getIsPlaying()
                : true;

            // Only consider BG lines that are relevant right now:
            // - previously active BG lines
            // - BG lines already in hot/buffered sets
            // - BG lines paired with currently-hot main lines (core may have enabled them early)
            const candidateIndexes = new Set();
            const addIndex = (idx) => {
                if (!Number.isInteger(idx) || idx < 0) return;
                candidateIndexes.add(idx);
            };
            for (const idx of bgActiveIndexes) addIndex(idx);
            for (const idx of (lyricPlayer.hotLines ?? [])) {
                addIndex(idx);
                const maybeMain = lines?.[idx];
                if (maybeMain && !maybeMain.isBG) {
                    const bgIdx = findPairedBgIndex(idx);
                    if (bgIdx !== -1) addIndex(bgIdx);
                }
            }
            for (const idx of (lyricPlayer.bufferedLines ?? [])) addIndex(idx);

            for (const idx of candidateIndexes) {
                const lineObj = lyricPlayer.currentLyricLineObjects[idx];
                const line = lineObj?.getLine?.() ?? lineObj?.lyricLine;
                if (!line?.isBG) continue;

                const pairedMainIndex = getPairedMainLineIndex(idx);
                const mainStillVisible = isMainLineStillVisible(pairedMainIndex);
                const inOwnTimeWindow =
                    Number.isFinite(line.startTime)
                    && Number.isFinite(line.endTime)
                    && timeMs >= line.startTime
                    && timeMs < line.endTime;
                const started = Number.isFinite(line.startTime) && timeMs >= line.startTime;
                const mainForcedExit = forcedExitedMainLines.has(pairedMainIndex);
                const shouldBeActive = !mainForcedExit && (inOwnTimeWindow || (started && mainStillVisible));
                const wasActive = bgActiveIndexes.has(idx);
                const isEnabled = lineObj?.isEnabled === true;

                if (shouldBeActive) {
                    nextActive.add(idx);
                    if (!lyricPlayer.hotLines?.has(idx)) {
                        lyricPlayer.hotLines?.add(idx);
                        layoutChanged = true;
                    }
                    if (!lyricPlayer.bufferedLines?.has(idx)) {
                        lyricPlayer.bufferedLines?.add(idx);
                        layoutChanged = true;
                    }
                    if (!isEnabled && typeof lineObj?.enable === "function") {
                        lineObj.enable(timeMs, isPlaying);
                    }
                    if ((force || !wasActive) && typeof lineObj?.setMaskAnimationState === "function") {
                        lineObj.setMaskAnimationState(timeMs);
                    }
                } else {
                    if (lyricPlayer.hotLines?.has(idx)) {
                        lyricPlayer.hotLines.delete(idx);
                        layoutChanged = true;
                    }
                    if (lyricPlayer.bufferedLines?.has(idx)) {
                        lyricPlayer.bufferedLines.delete(idx);
                        layoutChanged = true;
                    }
                    // Core can enable BG lines early when a main line becomes hot. Always disable if it's enabled
                    // but not within its own timing window (prevents "plays twice" and early animation).
                    if ((wasActive || isEnabled) && typeof lineObj?.disable === "function") {
                        lineObj.disable();
                    }
                }
            }

            bgActiveIndexes = nextActive;
            return layoutChanged;
        };

	        // Ensure time is integer ms and keep x-bg activation tied to its own begin/end.
	        const coreSetCurrentTime = lyricPlayer.setCurrentTime.bind(lyricPlayer);
	        const findPairedBgIndex = (mainIndex) => {
	            if (!Array.isArray(lyricPlayer.processedLines)) return -1;
	            const bgIndex = mainIndex + 1;
	            if (bgIndex >= 0 && bgIndex < lyricPlayer.processedLines.length && lyricPlayer.processedLines[bgIndex]?.isBG) {
	                return bgIndex;
	            }
	            return -1;
	        };
	        const originalSetCurrentTime = (ms, force = false) => {
	            const timeMs = Math.max(0, Math.floor(ms));
	            const delta = Math.abs(timeMs - lastKnownTimeMs);
	            lastKnownTimeMs = timeMs;
	            forcedExitedMainLines = new Set();
	            coreSetCurrentTime(timeMs, force);
	            const layoutDirty = enforceBGTimingWindows(timeMs, force || delta > 500);
	            applyNearSwitchRetreatVisual(timeMs);
	            if (layoutDirty && typeof lyricPlayer.calcLayout === "function") {
	                lyricPlayer.calcLayout();
	            }
	        };
	        lyricPlayer.setCurrentTime = originalSetCurrentTime;
	        let leadInMs = 300;
	        let generalLeadInMs = 0;
	        let nearSwitchGapMs = 70;
	        let nearSwitchWordLeadInRatio = 0.6;
	        let timeOffsetMs = 0;
	        let lastTTML = "";
	        let lineTimingOnlyMode = false;
	        let nearSwitchRetreatMeta = new Map(); // lineIndex -> { retreatStart, retreatEnd, maskFrom, maskTo, actualRetreatStart?, actualRetreatEnd? }
	        const hasEffectiveWordTiming = (line) => {
	            if (!line || !Array.isArray(line.words) || line.words.length < 2) return false;
	            const pairs = new Set();
	            for (const word of line.words) {
	                if (!Number.isFinite(word?.startTime) || !Number.isFinite(word?.endTime)) continue;
	                const s = Math.round(word.startTime);
	                const e = Math.round(word.endTime);
	                if (e < s) continue;
	                pairs.add(`${s}:${e}`);
	                if (pairs.size > 1) return true;
	            }
	            return false;
	        };
	        const hasTailHighlightOverflow = (line, newEnd) => {
	            if (!line || !Array.isArray(line.words) || !Number.isFinite(newEnd)) return false;
	            return line.words.some((word) => Number.isFinite(word?.endTime) && word.endTime > newEnd);
	        };
	        const applyNearSwitchRetreatVisual = (timeMs) => {
	            if (!Array.isArray(lyricPlayer.currentLyricLineObjects) || nearSwitchRetreatMeta.size === 0) {
	                return;
	            }
	            for (const [idx, meta] of nearSwitchRetreatMeta.entries()) {
	                const obj = lyricPlayer.currentLyricLineObjects[idx];
	                const mainElement = obj?.element?.children?.[0];
	                if (!obj || !mainElement || !meta) continue;
	
	                const retreatStart = Number.isFinite(meta.retreatStart) ? meta.retreatStart : null;
	                const retreatEnd = Number.isFinite(meta.retreatEnd) ? meta.retreatEnd : null;
	                const maskFrom = Number.isFinite(meta.maskFrom) ? meta.maskFrom : null;
	                const maskTo = Number.isFinite(meta.maskTo) ? meta.maskTo : null;
	                if (
	                    retreatStart === null || retreatEnd === null || retreatEnd <= retreatStart
	                    || maskFrom === null || maskTo === null || maskTo <= maskFrom
	                ) {
	                    mainElement.style.opacity = "";
	                    nearSwitchRetreatMeta.delete(idx);
	                    continue;
	                }
	
	                // Strict rule: do not compress while line is still in normal (enabled) display state.
	                if (obj.isEnabled === true) {
	                    mainElement.style.opacity = "";
	                    continue;
	                }

	                if (timeMs < retreatStart) {
	                    mainElement.style.opacity = "";
	                    continue;
	                }

	                const retreatDuration = Math.max(1, retreatEnd - retreatStart);
	                if (!Number.isFinite(meta.actualRetreatStart) || !Number.isFinite(meta.actualRetreatEnd)) {
	                    meta.actualRetreatStart = timeMs;
	                    meta.actualRetreatEnd = timeMs + retreatDuration;
	                }

	                const actualRetreatStart = meta.actualRetreatStart;
	                const actualRetreatEnd = meta.actualRetreatEnd;

	                if (timeMs >= actualRetreatEnd) {
	                    if (typeof obj?.setMaskAnimationState === "function") {
	                        obj.setMaskAnimationState(maskTo);
	                    }
	                    mainElement.style.opacity = "";
	                    if (timeMs > actualRetreatEnd + 150) {
	                        nearSwitchRetreatMeta.delete(idx);
	                    }
	                    continue;
	                }

	                const progress = Math.max(0, Math.min(1, (timeMs - actualRetreatStart) / (actualRetreatEnd - actualRetreatStart)));
	                const virtualMaskTime = maskFrom + (maskTo - maskFrom) * progress;
	                if (typeof obj?.setMaskAnimationState === "function") {
	                    obj.setMaskAnimationState(virtualMaskTime);
	                }
	                const fade = 1 - progress * 0.45;
	                mainElement.style.opacity = `${Math.max(0.35, Math.min(1, fade))}`;
	            }
	        };
	        const normalizeMainLinesForLineTimingMode = (lines) => {
	            if (!Array.isArray(lines) || lines.length === 0) return false;
	            const mainIndexes = [];
	            for (let i = 0; i < lines.length; i++) {
	                if (lines[i] && !lines[i].isBG) mainIndexes.push(i);
	            }
	            if (mainIndexes.length === 0) return false;
	            const allFlat = mainIndexes.every((idx) => !hasEffectiveWordTiming(lines[idx]));
	            if (!allFlat) return false;
	            for (const idx of mainIndexes) {
	                const line = lines[idx];
	                if (!line) continue;
	                const text = Array.isArray(line.words)
	                    ? line.words.map((w) => (typeof w?.word === "string" ? w.word : "")).join("")
	                    : "";
	                const lineStart = Number.isFinite(line.startTime) ? line.startTime : 0;
	                const lineEnd = Number.isFinite(line.endTime)
	                    ? Math.max(lineStart, line.endTime)
	                    : lineStart;
	                const firstWord = Array.isArray(line.words) && line.words.length > 0 ? line.words[0] : {};
	                line.words = [{
	                    ...firstWord,
	                    word: text,
	                    startTime: lineStart,
	                    endTime: lineEnd,
	                    obscene: false,
	                    romanWord: "",
	                }];
	            }
	            return true;
	        };
	        const shiftLineStartEarlier = (line, shift, wordShift = shift) => {
	            if (!line || !Number.isFinite(shift) || shift <= 0) return;
	            const oldStart = Number.isFinite(line.startTime) ? line.startTime : 0;
	            const newStart = Math.max(0, oldStart - shift);
	            line.startTime = newStart;
	            if (!Array.isArray(line.words) || !Number.isFinite(wordShift) || wordShift <= 0) return;
	            for (const word of line.words) {
	                if (Number.isFinite(word.startTime)) {
	                    word.startTime = Math.max(0, word.startTime - wordShift);
	                }
	                if (Number.isFinite(word.endTime)) {
	                    word.endTime = Math.max(
	                        Number.isFinite(word.startTime) ? word.startTime : 0,
	                        word.endTime - wordShift
	                    );
	                }
	            }
	        };
	        const applyNearSwitchLeadIn = (lines) => {
	            if (!Array.isArray(lines) || lines.length === 0) return;
	            const hasNearLeadIn = Number.isFinite(leadInMs) && leadInMs > 0 && Number.isFinite(nearSwitchGapMs) && nearSwitchGapMs > 0;
	            const hasGeneralLeadIn = Number.isFinite(generalLeadInMs) && generalLeadInMs > 0;
	            if (!hasNearLeadIn && !hasGeneralLeadIn) return;
	
	            const mainIndexes = [];
	            for (let i = 0; i < lines.length; i++) {
	                const line = lines[i];
	                if (line && !line.isBG) mainIndexes.push(i);
	            }
	            if (mainIndexes.length < 2) return;
	
	            const startShiftByIndex = new Map();
	            const startWordShiftByIndex = new Map();
	            const endShiftByIndex = new Map();
	            nearSwitchRetreatMeta = new Map();
	            const getPairedBg = (mainIdx) => {
	                const bgIdx = mainIdx + 1;
	                return lines[bgIdx]?.isBG ? bgIdx : -1;
	            };
	
	            for (let i = 0; i < mainIndexes.length - 1; i++) {
	                const currentIndex = mainIndexes[i];
	                const nextIndex = mainIndexes[i + 1];
	                const currentLine = lines[currentIndex];
	                const nextLine = lines[nextIndex];
	                if (!currentLine || !nextLine) continue;
	
	                const currentStart = Number.isFinite(currentLine.startTime) ? currentLine.startTime : 0;
	                const currentEnd = Number.isFinite(currentLine.endTime) ? currentLine.endTime : currentStart;
	                const nextStart = Number.isFinite(nextLine.startTime) ? nextLine.startTime : currentEnd;
	                const currentDuration = Math.max(0, currentEnd - currentStart);
	                const nextHeadroom = Math.max(0, nextStart);
	                const budget = Math.min(currentDuration, nextHeadroom);
	                if (!(budget > 0)) continue;
	                const gap = nextStart - currentEnd;
	                const baseShift = hasGeneralLeadIn ? Math.min(generalLeadInMs, budget) : 0;
	                const nearEligible = hasNearLeadIn && gap >= 0 && gap < nearSwitchGapMs;
	                const nearExtra = nearEligible ? Math.min(leadInMs, Math.max(0, budget - baseShift)) : 0;
	                const shift = baseShift + nearExtra;
	                if (!(shift > 0)) continue;
	
	                endShiftByIndex.set(currentIndex, Math.max(endShiftByIndex.get(currentIndex) ?? 0, shift));
	                startShiftByIndex.set(nextIndex, Math.max(startShiftByIndex.get(nextIndex) ?? 0, shift));
	                const mainWordShift = Math.max(0, Math.min(shift, shift * nearSwitchWordLeadInRatio));
	                startWordShiftByIndex.set(nextIndex, Math.max(startWordShiftByIndex.get(nextIndex) ?? 0, mainWordShift));
	                const curBgIndex = currentIndex + 1;
	                if (lines[curBgIndex]?.isBG) {
	                    endShiftByIndex.set(curBgIndex, Math.max(endShiftByIndex.get(curBgIndex) ?? 0, shift));
	                }
	                const nextBgIndex = getPairedBg(nextIndex);
	                if (nextBgIndex !== -1) {
	                    // BG under an early-switched main line must receive the same lead-in.
	                    startShiftByIndex.set(nextBgIndex, Math.max(startShiftByIndex.get(nextBgIndex) ?? 0, shift));
	                    startWordShiftByIndex.set(nextBgIndex, Math.max(startWordShiftByIndex.get(nextBgIndex) ?? 0, mainWordShift));
	                }
	            }

	            for (const [idx, shift] of startShiftByIndex.entries()) {
	                const line = lines[idx];
	                if (!line) continue;
	                const lineHasWordTiming = hasEffectiveWordTiming(line);
	                const wordShift = lineHasWordTiming
	                    ? Math.max(0, Math.min(shift, startWordShiftByIndex.get(idx) ?? shift))
	                    : shift;
	                shiftLineStartEarlier(line, shift, wordShift);
	            }
	
	            for (const [idx, shift] of endShiftByIndex.entries()) {
	                const line = lines[idx];
	                if (!line) continue;
	                const oldEnd = Number.isFinite(line.endTime) ? line.endTime : line.startTime;
	                const lineStart = Number.isFinite(line.startTime) ? line.startTime : 0;
	                const newEnd = Math.max(lineStart + 1, oldEnd - shift);
	                const needsRetreatCompression = hasTailHighlightOverflow(line, newEnd);
	                line.endTime = newEnd;
	                if (!line.isBG && needsRetreatCompression) {
	                    const retreatWindow = Math.max(60, Math.min(220, oldEnd - newEnd));
	                    nearSwitchRetreatMeta.set(idx, {
	                        // Strict rule: no compression while line is still in normal display.
	                        retreatStart: newEnd,
	                        retreatEnd: newEnd + retreatWindow,
	                        maskFrom: newEnd,
	                        maskTo: oldEnd,
	                    });
	                }
	            }
	        };
	        const applyTimeOffset = (line) => {
	            if (!line) return;
	            const offset = Number.isFinite(timeOffsetMs) ? timeOffsetMs : 0;
	            if (!offset) return;
            const adjust = (value) => Math.max(0, value + offset);

            if (Number.isFinite(line.startTime)) {
                line.startTime = adjust(line.startTime);
            }
            if (Number.isFinite(line.endTime)) {
                line.endTime = Math.max(
                    Number.isFinite(line.startTime) ? line.startTime : 0,
                    adjust(line.endTime)
                );
            }
            if (Array.isArray(line.words)) {
                line.words.forEach((word) => {
                    if (Number.isFinite(word.startTime)) {
                        word.startTime = adjust(word.startTime);
                    }
                    if (Number.isFinite(word.endTime)) {
                        word.endTime = Math.max(
                            Number.isFinite(word.startTime) ? word.startTime : 0,
                            adjust(word.endTime)
                        );
                    }
                });
            }
        };

        // Define the Renderer Implementation for Bridge
        window.LyricsRenderer = {
            setLyrics: (ttml) => {
                if (!ttml) {
                    lyricPlayer.setLyricLines([]);
                    bgActiveIndexes = new Set();
                    lineTimingOnlyMode = false;
                    console.log("[LyricsRenderer] Cleared lyrics");
                    lastTTML = "";
                    return;
                }
	                try {
		                    lastTTML = ttml;
		                    const result = parseTTML(ttml);
		                    const lines = result.lines.map(mapTTMLLyric);
		                    lines.forEach(applyTimeOffset);
		                    lineTimingOnlyMode = normalizeMainLinesForLineTimingMode(lines);
		                    console.log(`[LyricsRenderer] lineTimingOnlyMode=${lineTimingOnlyMode}`);
		                    try {
		                        applyNearSwitchLeadIn(lines);
		                    } catch (e) {
		                        console.error("[LyricsRenderer] applyNearSwitchLeadIn error:", e);
		                    }
			                    const timingSnapshot = captureTimingSnapshot(lines);
			                    // Preserve TTML intent (no mutation of duet/bg/ordering).
			                    lyricPlayer.setLyricLines(lines);
	                    if (lineTimingOnlyMode === true) {
	                        // Force AMLL to use non-dynamic line opacity behavior for pure line-timing lyrics.
	                        lyricPlayer.isNonDynamic = true;
	                    }
		                    const currentMs = Number.isFinite(lastKnownTimeMs)
		                        ? lastKnownTimeMs
		                        : (lyricPlayer.getCurrentTime ? lyricPlayer.getCurrentTime() : 0);
	                    // Undo core timing normalization so x-bg keeps original line/word timing.
	                    restoreTimingSnapshot(timingSnapshot);
	                    // Core may have already generated mask animations based on its normalized timing.
	                    // Rebuild masks for currently-built lines so per-word highlight uses restored TTML timing.
	                    if (Array.isArray(lyricPlayer.currentLyricLineObjects)) {
	                        for (const obj of lyricPlayer.currentLyricLineObjects) {
	                            if (obj?.built && typeof obj.updateMaskImageSync === "function") {
	                                obj.updateMaskImageSync();
	                            }
	                        }
	                    }
	                    assertXBgTiming(ttml, lines);
		                    // Re-align playback position after (re)loading lyrics.
		                    originalSetCurrentTime(currentMs, true);
                            externalTimeMs = currentMs;
                            externalTimeAnchorPerfMs = performance.now();
		                    console.log("[LyricsRenderer] Loaded lines:", lines.length);
		                } catch (e) {
                    console.error("[LyricsRenderer] TTML Parse Error:", e);
                    // Optionally fallback to plain text parsing if you had that logic
                }
            },
            
	            setCurrentTime: (seconds) => {
	                const timeInMs = Math.max(0, Math.floor(seconds * 1000));
	                // If AMLL hasn't finished its first layout yet, non-forced setCurrentTime is ignored.
	                const needsForce = lyricPlayer.initialLayoutFinished === false;
	                originalSetCurrentTime(timeInMs, needsForce);
                    externalTimeMs = timeInMs;
                    externalTimeAnchorPerfMs = performance.now();
	            },
	            
	            setPlaying: (isPlaying) => {
                    externalIsPlaying = !!isPlaying;
                    externalTimeMs = Number.isFinite(lastKnownTimeMs) ? lastKnownTimeMs : externalTimeMs;
                    externalTimeAnchorPerfMs = performance.now();
                    if (externalIsPlaying) {
                        if (typeof lyricPlayer.resume === "function") {
                            lyricPlayer.resume();
                        }
                    } else if (typeof lyricPlayer.pause === "function") {
                        lyricPlayer.pause();
                    }
	            },
            
		            setConfig: (config) => {
		                try {
		                    let needsLyricsReload = false;
		                    if (typeof config.renderScale === "number" && !Number.isNaN(config.renderScale)) {
		                        const nextRenderScale = Math.max(0.35, Math.min(1.0, config.renderScale));
		                        if (nextRenderScale !== renderScale && typeof lyricPlayer.setRenderScale === "function") {
		                            renderScale = nextRenderScale;
		                            lyricPlayer.setRenderScale(renderScale);
		                        }
		                    }
		                    // Apply config to lyricPlayer
		                    if (config.fontSize) {
		                        lyricPlayer.getElement().style.setProperty("--amll-lp-font-size", `${config.fontSize}px`);
		                    }
	                    if (config.fontWeight) {
	                        lyricPlayer.getElement().style.setProperty("--amll-lp-main-font-weight", `${config.fontWeight}`);
	                    }
	                    if (config.translationFontWeight) {
	                        lyricPlayer.getElement().style.setProperty(
	                            "--amll-lp-translation-font-weight",
	                            `${config.translationFontWeight}`
	                        );
	                    }
	                    if (config.translationFontSize) {
	                        lyricPlayer.getElement().style.setProperty(
	                            "--amll-lp-translation-font-size",
	                            `${config.translationFontSize}px`
	                        );
	                    }
	                    if (config.fontFamilyMain) {
	                        lyricPlayer.getElement().style.setProperty("--amll-lp-main-font-family", config.fontFamilyMain);
	                    }
	                    if (config.fontFamilyTranslation) {
	                        lyricPlayer.getElement().style.setProperty(
	                            "--amll-lp-translation-font-family",
	                            config.fontFamilyTranslation
	                        );
	                    }
	                    if (config.textColor) {
	                        lyricPlayer.getElement().style.setProperty("--amll-lp-color", config.textColor);
	                    }
	                    if (config.shadowColor) {
	                        lyricPlayer.getElement().style.textShadow = `0 1px 2px ${config.shadowColor}`;
	                    }
	                    if (typeof config.leadInMs === "number" && !Number.isNaN(config.leadInMs)) {
	                        const nextLeadInMs = Math.max(0, Math.min(1200, config.leadInMs));
	                        if (nextLeadInMs !== leadInMs) {
	                            leadInMs = nextLeadInMs;
	                            needsLyricsReload = true;
	                        }
	                    }
	                    if (typeof config.generalLeadInMs === "number" && !Number.isNaN(config.generalLeadInMs)) {
	                        const nextGeneralLeadInMs = Math.max(0, Math.min(1200, config.generalLeadInMs));
	                        if (nextGeneralLeadInMs !== generalLeadInMs) {
	                            generalLeadInMs = nextGeneralLeadInMs;
	                            needsLyricsReload = true;
	                        }
	                    }
	                    if (typeof config.nearSwitchGapMs === "number" && !Number.isNaN(config.nearSwitchGapMs)) {
	                        const nextNearSwitchGapMs = Math.max(0, Math.min(300, config.nearSwitchGapMs));
	                        if (nextNearSwitchGapMs !== nearSwitchGapMs) {
	                            nearSwitchGapMs = nextNearSwitchGapMs;
	                            needsLyricsReload = true;
	                        }
	                    }
	                    if (typeof config.nearSwitchWordLeadInRatio === "number" && !Number.isNaN(config.nearSwitchWordLeadInRatio)) {
	                        const nextRatio = Math.max(0, Math.min(1, config.nearSwitchWordLeadInRatio));
	                        if (nextRatio !== nearSwitchWordLeadInRatio) {
	                            nearSwitchWordLeadInRatio = nextRatio;
	                            needsLyricsReload = true;
	                        }
	                    }
	                    if (typeof config.timeOffsetMs === "number" && !Number.isNaN(config.timeOffsetMs)) {
	                        const nextTimeOffsetMs = Math.max(-15000, Math.min(15000, config.timeOffsetMs));
	                        if (nextTimeOffsetMs !== timeOffsetMs) {
	                            timeOffsetMs = nextTimeOffsetMs;
	                            needsLyricsReload = true;
	                        }
	                    }
	                    if (needsLyricsReload && lastTTML) {
	                        window.LyricsRenderer.setLyrics(lastTTML);
	                    }
	                    console.log("[LyricsRenderer] Config updated:", config);
	                } catch (e) {
	                    console.error("[LyricsRenderer] Config Error:", e);
	                }
	            }
        };

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const delta = time - lastTime;
            lastTime = time;
            if (externalIsPlaying) {
                const predictedTimeMs = Math.max(
                    0,
                    Math.floor(externalTimeMs + (time - externalTimeAnchorPerfMs))
                );
                // Keep AMLL progression smooth in JS without requiring high-frequency Swift updates.
                if (Math.abs(predictedTimeMs - lastKnownTimeMs) >= 1) {
                    originalSetCurrentTime(predictedTimeMs, false);
                }
            }
            lyricPlayer.update(delta);
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        // Notify bridge that renderer is ready (after LyricsRenderer defined)
        if (window.AMLL && typeof window.AMLL._onRendererReady === "function") {
            window.AMLL._onRendererReady();
        } else {
            console.warn("[LyricsRenderer] AMLL bridge not ready");
        }

    </script>
</body>
</html>
