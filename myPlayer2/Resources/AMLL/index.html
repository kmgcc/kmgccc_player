<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMLL Lyrics</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: transparent;
        }
        #player {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .amll-lyric-player {
            font-family: var(--amll-lp-main-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-main-font-weight, 600);
        }
        .amll-lyric-player.dom,
        .amll-lyric-player.dom-slim {
            line-height: 1.44em;
        }
        ._lyricLine_m23bz_6,
        ._lyricLine_1jop6_6 {
            overflow: visible;
        }
        ._lyricMainLine_m23bz_99,
        ._lyricMainLine_1jop6_80 {
            font-family: var(--amll-lp-main-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-main-font-weight, 600);
            line-height: 1.42em;
            padding-bottom: 1.05em;
        }
        ._lyricSubLine_m23bz_145,
        ._lyricSubLine_1jop6_90 {
            font-family: var(--amll-lp-translation-font-family, -apple-system, "Helvetica Neue", sans-serif);
            font-weight: var(--amll-lp-translation-font-weight, 400);
            font-size: var(--amll-lp-translation-font-size, 0.75em);
            line-height: 1.42em;
        }

        /* Background (small) lyric lines:
           hidden by default, fade in only when active, fade out after active ends. */
        .amll-lyric-player [class*="_lyricBgLine_"] {
            opacity: 0 !important;
            padding-top: 0.2em !important;
            padding-bottom: 0.2em !important;
            scale: 1 !important;
            transition: opacity .32s ease !important;
        }
        .amll-lyric-player [class*="_lyricBgLine_"][class*="_active_"] {
            opacity: 0.4 !important;
            scale: 1 !important;
        }

        /* Animate text inside bg-line so we don't override AMLL line positioning transform. */
        .amll-lyric-player [class*="_lyricBgLine_"] > * {
            transform: translateY(10px);
            transition: transform .42s ease, opacity .32s ease;
        }
        .amll-lyric-player [class*="_lyricBgLine_"][class*="_active_"] > * {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="player"></div>

    <!-- Load Bridge first so logs & AMLL namespace are available -->
    <script src="bridge.js"></script>

    <script type="module">
        import { LyricPlayer, parseTTML } from "./amll-core.js";

        console.log("[LyricsRenderer] Module script loaded");

        // Initialize Player
        const playerContainer = document.getElementById('player');
        const lyricPlayer = new LyricPlayer();
        playerContainer.appendChild(lyricPlayer.getElement());
        
        // Initial config defaults
        lyricPlayer.setEnableSpring(true);
        lyricPlayer.setEnableBlur(true);
        lyricPlayer.setWordFadeWidth(0.7);
        // Align active line toward top (instead of center)
        lyricPlayer.setAlignAnchor("top");
        lyricPlayer.setAlignPosition(0.2);
        
        // Helper to map TTML lines to AMLL LyricLine format
        const mapTTMLLyric = (line) => ({
            ...line,
            words: line.words.map((word) => ({ obscene: false, romanWord: "", ...word })),
            romanLyric: "",
        });

        let lastSeekAt = 0;
        let lastSeekSeconds = null;
        const emitSeek = (line) => {
            if (!line) return;
            const start = typeof line.startTime === "number" ? line.startTime : undefined;
            if (start === undefined || Number.isNaN(start)) return;

            const currentMs = typeof lyricPlayer.getCurrentTime === "function"
                ? lyricPlayer.getCurrentTime()
                : 0;
            const looksLikeMs = start > 1000 || (currentMs > 0 && Math.abs(start - currentMs) < 5000);
            const seconds = looksLikeMs ? start / 1000 : start;

            const now = performance.now();
            if (lastSeekSeconds !== null && Math.abs(seconds - lastSeekSeconds) < 0.01 && now - lastSeekAt < 250) {
                return;
            }
            lastSeekAt = now;
            lastSeekSeconds = seconds;

            if (window.AMLL && typeof window.AMLL._onUserSeek === "function") {
                window.AMLL._onUserSeek(seconds);
            } else if (window.webkit?.messageHandlers?.onUserSeek) {
                window.webkit.messageHandlers.onUserSeek.postMessage({ seconds });
            }
        };

        const resolveLineFromTarget = (target) => {
            let node = target;
            const root = lyricPlayer.getElement();
            while (node && node !== root) {
                const lineObj = lyricPlayer.lyricLineElementMap?.get?.(node);
                if (lineObj?.getLine) return lineObj.getLine();
                node = node.parentElement;
            }
            return null;
        };

        // Seek on line click (notify native)
        lyricPlayer.addEventListener("line-click", (e) => {
            emitSeek(e?.line);
        });

        // Fallback: resolve clicked line from DOM target (some WebKit builds drop line-click)
        lyricPlayer.getElement().addEventListener("click", (e) => {
            const line = resolveLineFromTarget(e.target);
            emitSeek(line);
        });

        const parseTTMLTimeToMs = (value) => {
            if (typeof value !== "string" || value.length === 0) return null;
            if (value.endsWith("ms")) {
                const n = Number.parseFloat(value.slice(0, -2));
                return Number.isFinite(n) ? Math.round(n) : null;
            }
            if (value.endsWith("s")) {
                const n = Number.parseFloat(value.slice(0, -1));
                return Number.isFinite(n) ? Math.round(n * 1000) : null;
            }
            const parts = value.split(":");
            if (parts.length === 2 || parts.length === 3) {
                const nums = parts.map((part) => Number.parseFloat(part));
                if (nums.some((n) => !Number.isFinite(n))) return null;
                if (parts.length === 2) {
                    return Math.round((nums[0] * 60 + nums[1]) * 1000);
                }
                return Math.round((nums[0] * 3600 + nums[1] * 60 + nums[2]) * 1000);
            }
            const raw = Number.parseFloat(value);
            return Number.isFinite(raw) ? Math.round(raw * 1000) : null;
        };

        const collectXBgFromTTML = (ttml) => {
            if (typeof ttml !== "string" || ttml.trim().length === 0) return [];
            const xml = new DOMParser().parseFromString(ttml, "application/xml");
            if (xml.querySelector("parsererror")) {
                return [];
            }

            const nodes = Array.from(xml.getElementsByTagName("*")).filter((el) => {
                if (el.localName !== "span") return false;
                const role =
                    el.getAttribute("ttm:role")
                    || el.getAttributeNS("http://www.w3.org/ns/ttml#metadata", "role")
                    || el.getAttribute("role");
                return role === "x-bg";
            });

            return nodes.map((node) => {
                const words = Array.from(node.children)
                    .filter((child) => child.localName === "span")
                    .map((child) => ({
                        startTime: parseTTMLTimeToMs(child.getAttribute("begin")),
                        endTime: parseTTMLTimeToMs(child.getAttribute("end")),
                        text: (child.textContent || "").trim(),
                    }));
                return {
                    startTime: parseTTMLTimeToMs(node.getAttribute("begin")),
                    endTime: parseTTMLTimeToMs(node.getAttribute("end")),
                    words,
                };
            });
        };

        const assertXBgTiming = (ttml, parsedLines) => {
            const source = collectXBgFromTTML(ttml);
            if (source.length === 0) return;

            const parsed = (Array.isArray(parsedLines) ? parsedLines : [])
                .filter((line) => line?.isBG)
                .map((line) => ({
                    startTime: Number.isFinite(line.startTime) ? line.startTime : null,
                    endTime: Number.isFinite(line.endTime) ? line.endTime : null,
                    words: Array.isArray(line.words)
                        ? line.words.map((word) => ({
                            startTime: Number.isFinite(word.startTime) ? word.startTime : null,
                            endTime: Number.isFinite(word.endTime) ? word.endTime : null,
                            text: (word.word || "").trim(),
                        }))
                        : [],
                }));

            console.log(
                `[LyricsRenderer][x-bg][assert] source=${source.length}, parsed=${parsed.length}`
            );
            if (source.length !== parsed.length) {
                console.error("[LyricsRenderer][x-bg][assert] line count mismatch");
            }

            const n = Math.min(source.length, parsed.length);
            for (let i = 0; i < n; i++) {
                const src = source[i];
                const expected = {
                    startTime: Number.isFinite(src.startTime) ? Math.max(0, src.startTime + timeOffsetMs) : null,
                    endTime: Number.isFinite(src.endTime) ? Math.max(0, src.endTime + timeOffsetMs) : null,
                    words: src.words.map((word) => ({
                        startTime: Number.isFinite(word.startTime)
                            ? Math.max(0, word.startTime + timeOffsetMs)
                            : null,
                        endTime: Number.isFinite(word.endTime)
                            ? Math.max(0, word.endTime + timeOffsetMs)
                            : null,
                        text: word.text,
                    })),
                };
                const got = parsed[i];
                const startOk = expected.startTime === got.startTime;
                const endOk = expected.endTime === got.endTime;
                const wordCountOk = expected.words.length === got.words.length;
                const firstWordStartOk =
                    expected.words.length === 0
                    || got.words.length === 0
                    || expected.words[0].startTime === got.words[0].startTime;
                const lastWordEndOk =
                    expected.words.length === 0
                    || got.words.length === 0
                    || expected.words[expected.words.length - 1].endTime === got.words[got.words.length - 1].endTime;
                const ok = startOk && endOk && wordCountOk && firstWordStartOk && lastWordEndOk;

                if (ok) {
                    console.log(
                        `[LyricsRenderer][x-bg][assert] #${i} PASS start=${got.startTime} end=${got.endTime} words=${got.words.length}`
                    );
                } else {
                    console.error(
                        `[LyricsRenderer][x-bg][assert] #${i} FAIL expected=${JSON.stringify(expected)} parsed=${JSON.stringify(got)}`
                    );
                }
            }
        };

        const captureTimingSnapshot = (lines) => {
            if (!Array.isArray(lines)) return [];
            return lines.map((line) => ({
                startTime: Number.isFinite(line?.startTime) ? line.startTime : null,
                endTime: Number.isFinite(line?.endTime) ? line.endTime : null,
                words: Array.isArray(line?.words)
                    ? line.words.map((word) => ({
                        startTime: Number.isFinite(word?.startTime) ? word.startTime : null,
                        endTime: Number.isFinite(word?.endTime) ? word.endTime : null,
                    }))
                    : [],
            }));
        };

        const applyTimingSnapshot = (lines, snapshot) => {
            if (!Array.isArray(lines) || !Array.isArray(snapshot) || lines.length !== snapshot.length) {
                return false;
            }
            lines.forEach((line, idx) => {
                const snap = snapshot[idx];
                if (!line || !snap) return;
                if (Number.isFinite(snap.startTime)) line.startTime = snap.startTime;
                if (Number.isFinite(snap.endTime)) line.endTime = snap.endTime;
                if (!Array.isArray(line.words) || !Array.isArray(snap.words)) return;
                const wordCount = Math.min(line.words.length, snap.words.length);
                for (let wi = 0; wi < wordCount; wi++) {
                    const word = line.words[wi];
                    const wordSnap = snap.words[wi];
                    if (!word || !wordSnap) continue;
                    if (Number.isFinite(wordSnap.startTime)) word.startTime = wordSnap.startTime;
                    if (Number.isFinite(wordSnap.endTime)) word.endTime = wordSnap.endTime;
                }
            });
            return true;
        };

        const restoreTimingSnapshot = (snapshot) => {
            const didProcessed = applyTimingSnapshot(lyricPlayer.processedLines, snapshot);
            const didCurrent = applyTimingSnapshot(lyricPlayer.currentLyricLines, snapshot);
            const objectLines = Array.isArray(lyricPlayer.currentLyricLineObjects)
                ? lyricPlayer.currentLyricLineObjects
                    .map((obj) => obj?.getLine?.() ?? obj?.lyricLine)
                    .filter(Boolean)
                : [];
            const didObjects = applyTimingSnapshot(objectLines, snapshot);
            return didProcessed || didCurrent || didObjects;
        };

        let lastKnownTimeMs = 0;
        let bgActiveIndexes = new Set();
        const getPairedMainLineIndex = (index) => {
            if (!Array.isArray(lyricPlayer.processedLines)) return -1;
            if (index > 0 && lyricPlayer.processedLines[index - 1] && !lyricPlayer.processedLines[index - 1].isBG) {
                return index - 1;
            }
            if (
                index + 1 < lyricPlayer.processedLines.length
                && lyricPlayer.processedLines[index + 1]
                && !lyricPlayer.processedLines[index + 1].isBG
            ) {
                return index + 1;
            }
            return -1;
        };
        const isMainLineStillVisible = (index) => {
            if (index < 0) return false;
            if (lyricPlayer.hotLines?.has(index) || lyricPlayer.bufferedLines?.has(index)) {
                return true;
            }
            const mainObj = lyricPlayer.currentLyricLineObjects?.[index];
            return mainObj?.isEnabled === true;
        };
        const enforceBGTimingWindows = (timeMs, force = false) => {
            if (!Array.isArray(lyricPlayer.currentLyricLineObjects)) {
                bgActiveIndexes = new Set();
                return;
            }

            const nextActive = new Set();
            let layoutChanged = false;
            const isPlaying = typeof lyricPlayer.getIsPlaying === "function"
                ? lyricPlayer.getIsPlaying()
                : true;

            lyricPlayer.currentLyricLineObjects.forEach((lineObj, idx) => {
                const line = lineObj?.getLine?.() ?? lineObj?.lyricLine;
                if (!line?.isBG) return;

                const pairedMainIndex = getPairedMainLineIndex(idx);
                const mainStillVisible = isMainLineStillVisible(pairedMainIndex);
                const inOwnTimeWindow =
                    Number.isFinite(line.startTime)
                    && Number.isFinite(line.endTime)
                    && timeMs >= line.startTime
                    && timeMs < line.endTime;
                const started = Number.isFinite(line.startTime) && timeMs >= line.startTime;
                const shouldBeActive = inOwnTimeWindow || (started && mainStillVisible);
                const wasActive = bgActiveIndexes.has(idx);

                if (shouldBeActive) {
                    nextActive.add(idx);
                    if (!lyricPlayer.hotLines?.has(idx)) {
                        lyricPlayer.hotLines?.add(idx);
                        layoutChanged = true;
                    }
                    if (!lyricPlayer.bufferedLines?.has(idx)) {
                        lyricPlayer.bufferedLines?.add(idx);
                        layoutChanged = true;
                    }
                    if (!wasActive && typeof lineObj?.enable === "function") {
                        lineObj.enable(timeMs, isPlaying);
                    }
                    if ((force || !wasActive) && typeof lineObj?.setMaskAnimationState === "function") {
                        lineObj.setMaskAnimationState(timeMs);
                    }
                } else {
                    if (lyricPlayer.hotLines?.has(idx)) {
                        lyricPlayer.hotLines.delete(idx);
                        layoutChanged = true;
                    }
                    if (lyricPlayer.bufferedLines?.has(idx)) {
                        lyricPlayer.bufferedLines.delete(idx);
                        layoutChanged = true;
                    }
                    if (wasActive && typeof lineObj?.disable === "function") {
                        lineObj.disable();
                    }
                }
            });

            if (layoutChanged && typeof lyricPlayer.calcLayout === "function") {
                lyricPlayer.calcLayout();
            }
            bgActiveIndexes = nextActive;
        };

        // Ensure time is integer ms and keep x-bg activation tied to its own begin/end.
        const coreSetCurrentTime = lyricPlayer.setCurrentTime.bind(lyricPlayer);
        const originalSetCurrentTime = (ms, force = false) => {
            const timeMs = Math.max(0, Math.floor(ms));
            const delta = Math.abs(timeMs - lastKnownTimeMs);
            lastKnownTimeMs = timeMs;
            coreSetCurrentTime(timeMs, force);
            enforceBGTimingWindows(timeMs, force || delta > 500);
        };
        lyricPlayer.setCurrentTime = originalSetCurrentTime;
        let leadInMs = 300;
        let timeOffsetMs = 0;
        let lastTTML = "";
        const applyLeadIn = (line) => {
            if (!line || line.isBG) return;
            const start = Number.isFinite(line.startTime) ? line.startTime : 0;
            const end = Number.isFinite(line.endTime) ? line.endTime : 0;
            if (!Array.isArray(line.words) || line.words.length === 0) {
                const shift = Math.min(leadInMs, start);
                line.startTime = Math.max(0, start - shift);
                line.endTime = Math.max(line.startTime, end - shift);
                return;
            }
            const firstWord = line.words[0];
            const wordStart = Number.isFinite(firstWord?.startTime) ? firstWord.startTime : start;
            const lastWord = line.words[line.words.length - 1];
            const lastWordEnd = Number.isFinite(lastWord?.endTime) ? lastWord.endTime : end;
            const shift = Math.min(leadInMs, start, wordStart, lastWordEnd);
            line.startTime = Math.max(0, start - shift);
            if (firstWord && Number.isFinite(firstWord.startTime)) {
                firstWord.startTime = Math.max(0, wordStart - shift);
            }
            const newEnd = Math.max(line.startTime, end - shift);
            line.endTime = newEnd;
            if (lastWord && Number.isFinite(lastWord.endTime)) {
                lastWord.endTime = Math.max(newEnd, lastWordEnd - shift);
            }
        };
        const applyTimeOffset = (line) => {
            if (!line) return;
            const offset = Number.isFinite(timeOffsetMs) ? timeOffsetMs : 0;
            if (!offset) return;
            const adjust = (value) => Math.max(0, value + offset);

            if (Number.isFinite(line.startTime)) {
                line.startTime = adjust(line.startTime);
            }
            if (Number.isFinite(line.endTime)) {
                line.endTime = Math.max(
                    Number.isFinite(line.startTime) ? line.startTime : 0,
                    adjust(line.endTime)
                );
            }
            if (Array.isArray(line.words)) {
                line.words.forEach((word) => {
                    if (Number.isFinite(word.startTime)) {
                        word.startTime = adjust(word.startTime);
                    }
                    if (Number.isFinite(word.endTime)) {
                        word.endTime = Math.max(
                            Number.isFinite(word.startTime) ? word.startTime : 0,
                            adjust(word.endTime)
                        );
                    }
                });
            }
        };

        // Define the Renderer Implementation for Bridge
        window.LyricsRenderer = {
            setLyrics: (ttml) => {
                if (!ttml) {
                    lyricPlayer.setLyricLines([]);
                    bgActiveIndexes = new Set();
                    console.log("[LyricsRenderer] Cleared lyrics");
                    lastTTML = "";
                    return;
                }
                try {
                    lastTTML = ttml;
                    const result = parseTTML(ttml);
                    const lines = result.lines.map(mapTTMLLyric);
                    lines.forEach(applyLeadIn);
                    lines.forEach(applyTimeOffset);
                    const timingSnapshot = captureTimingSnapshot(lines);
                    // Preserve TTML intent (no mutation of duet/bg/ordering).
                    lyricPlayer.setLyricLines(lines);
                    const currentMs = Number.isFinite(lastKnownTimeMs)
                        ? lastKnownTimeMs
                        : (lyricPlayer.getCurrentTime ? lyricPlayer.getCurrentTime() : 0);
                    // Undo core timing normalization so x-bg keeps original line/word timing.
                    restoreTimingSnapshot(timingSnapshot);
                    assertXBgTiming(ttml, lines);
                    // Re-align playback position after (re)loading lyrics.
                    originalSetCurrentTime(currentMs, true);
                    console.log("[LyricsRenderer] Loaded lines:", lines.length);
                } catch (e) {
                    console.error("[LyricsRenderer] TTML Parse Error:", e);
                    // Optionally fallback to plain text parsing if you had that logic
                }
            },
            
            setCurrentTime: (seconds) => {
                const timeInMs = Math.max(0, Math.floor(seconds * 1000));
                // If AMLL hasn't finished its first layout yet, non-forced setCurrentTime is ignored.
                const needsForce = lyricPlayer.initialLayoutFinished === false;
                originalSetCurrentTime(timeInMs, needsForce);
            },
            
            setPlaying: (isPlaying) => {
                // lyricPlayer.setIsPlaying(isPlaying); // If supported by core
            },
            
            setConfig: (config) => {
                try {
                    // Apply config to lyricPlayer
                    if (config.fontSize) {
                         lyricPlayer.getElement().style.setProperty("--amll-lp-font-size", `${config.fontSize}px`);
                    }
                    if (config.fontWeight) {
                        lyricPlayer.getElement().style.setProperty("--amll-lp-main-font-weight", `${config.fontWeight}`);
                    }
                    if (config.translationFontWeight) {
                        lyricPlayer.getElement().style.setProperty(
                            "--amll-lp-translation-font-weight",
                            `${config.translationFontWeight}`
                        );
                    }
                    if (config.translationFontSize) {
                        lyricPlayer.getElement().style.setProperty(
                            "--amll-lp-translation-font-size",
                            `${config.translationFontSize}px`
                        );
                    }
                    if (config.fontFamilyMain) {
                        lyricPlayer.getElement().style.setProperty("--amll-lp-main-font-family", config.fontFamilyMain);
                    }
                    if (config.fontFamilyTranslation) {
                        lyricPlayer.getElement().style.setProperty(
                            "--amll-lp-translation-font-family",
                            config.fontFamilyTranslation
                        );
                    }
                    if (config.textColor) {
                        lyricPlayer.getElement().style.setProperty("--amll-lp-color", config.textColor);
                    }
                    if (config.shadowColor) {
                        lyricPlayer.getElement().style.textShadow = `0 1px 2px ${config.shadowColor}`;
                    }
                    if (typeof config.leadInMs === "number" && !Number.isNaN(config.leadInMs)) {
                        leadInMs = Math.max(0, Math.min(1200, config.leadInMs));
                        if (lastTTML) {
                            window.LyricsRenderer.setLyrics(lastTTML);
                        }
                    }
                    if (typeof config.timeOffsetMs === "number" && !Number.isNaN(config.timeOffsetMs)) {
                        timeOffsetMs = Math.max(-15000, Math.min(15000, config.timeOffsetMs));
                        if (lastTTML) {
                            window.LyricsRenderer.setLyrics(lastTTML);
                        }
                    }
                    console.log("[LyricsRenderer] Config updated:", config);
                } catch (e) {
                    console.error("[LyricsRenderer] Config Error:", e);
                }
            }
        };

        // Animation Loop
        let lastTime = performance.now();
        function animate(time) {
            const delta = time - lastTime;
            lastTime = time;
            lyricPlayer.update(delta);
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);

        // Notify bridge that renderer is ready (after LyricsRenderer defined)
        if (window.AMLL && typeof window.AMLL._onRendererReady === "function") {
            window.AMLL._onRendererReady();
        } else {
            console.warn("[LyricsRenderer] AMLL bridge not ready");
        }

    </script>
</body>
</html>
